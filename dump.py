
from program import Program
from function import Function
import sys, os

import simcopter
import codeview
import tpi


from collections import defaultdict
import pydemangler



extrafiles = defaultdict(list)

def dump(p: Program, dest: str):
    extrafiles = []


    if not os.path.exists(dest):
        os.mkdir(dest)
    os.chdir(dest)

    for lib in p.libraries.values():
        if lib.is_dll() or lib.name in ["OLDNAMES.lib", "LIBCMTD.lib"]:
            print(f"Skipping {lib.name}")
            continue

        dump_lib(p, lib)


def fix_path(path, lib_prefix):
    path = path.lower().replace("\\", "/")
    if path.startswith(simcopter.source_prefix):
        return path[len(simcopter.source_prefix):]
    return lib_prefix + path

def dump_lib(p, lib):
    prefix = simcopter.libs[lib.name]
    print(f"Dumping {lib.name} to {prefix}")

    count = 10

    for module in lib.modules.values():
        module_path = fix_path(module.sourceFile, prefix)
        if module.sourceFile.lower().endswith((".asm", ".obj")):
            print(f"Skipping assembly module {module.name} at {module.sourceFile}")
            continue
        dump_module(p, module, module_path)
        count -= 1
        # if count <= 0:
        #     break


def dump_module(p, module, path):
    dirname = os.path.dirname(path)
    module_source = module.sourceFile.lower()
    if dirname:
        os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w") as f:
        f.write(f"// Module: {module.name}\n")
        f.write(f"// Source: {module.sourceFile}\n")
        f.write(f"// autogenerated by simcopter_tool from PDB file\n\n")

        for contrib in module.sectionContribs:
            f.write(f"\n\n// Contribution: {contrib}\n")

            for _, thing in sorted(contrib.things.items()):
                if isinstance(thing, Function):
                    func = thing


                    if func.name.endswith(" destructor'") or func.name.endswith(" iterator'"):
                        f.write(f"// FUNCTION: {p.exename} 0x{func.address:08x}\n")
                        f.write(f"// {func.name}\n\n")
                        continue

                    if func.name.startswith("$E"):
                        # todo: work out what the fuck these are
                        f.write(f"// FUNCTION: {p.exename} 0x{func.address:08x}\n")
                        f.write(f"// {func.name}\n\n")
                        continue

                    if func.name == "ResFile::~ResFile":
                        # fixme: hack to skip this one function
                        func.source_file = module_source

                    func_source = func.source_file.lower()
                    if func_source != module_source:
                        if "msdev/include" in func_source:
                            f.write(f"// LIBRARY: MSVC 0x{func.address:08x}\n")
                            f.write(f"// {func.name}\n\n")
                        else:
                            print(f"Warning: Function {func.name} in {func_source} does not match module source {module_source}")
                            extrafiles[func_source].append(func)
                        continue

                    f.write(f"// FUNCTION: {p.exename} 0x{func.address:08x}\n")

                    f.write(f"{func_sig(p, func)} {{\n")
                    for line, asm in func.disassemble():
                        f.write(f"// LINE {line:d}:\n\tasm( \n")

                        for asm_line in asm.split("\n")[:-1]:
                            f.write(f"\"\t{asm_line}\"\n")
                        f.write(");\n")

                    f.write("}\n\n")
                else:
                    sym = thing
                    if contrib.is_code():
                        f.write(f"// FUNCTION: {p.exename} 0x{sym.Offset:08x}\n")
                        breakpoint()
                    elif isinstance(sym, (codeview.GlobalData, codeview.PublicData)):
                        f.write(f"// GLOBAL: {p.exename} 0x{sym.Offset:08x}\n")
                    elif isinstance(sym, codeview.LocalData):
                        f.write(f"// LOCAL: {p.exename} 0x{sym.Offset:08x}\n")
                    else:
                        print(f"Unknown symbol\n {sym}")

                    f.write(f"// {sym.Name}\n")

def symbol_sig(p, sym):
    breakpoint()

def find_type(p, func):
    if not func.symbols:
        return None

    try:
        TI = func.symbols.Type
        if TI == 0:
            return None
    except AttributeError:
        return None

    return p.types.types[TI]

def func_sig(p, func):
    # try and find type info
    ty = find_type(p, func)
    if ty is None:
        if func.sym is not None:
            return pydemangler.demangle(func.sym.Name)
        return f"UNKNOWN_SIG void {func.name}(/* no symbols */)"

    if isinstance(ty, tpi.LfProcedure):
        args = []
    else:
        args = [arg.typestr() for arg in ty.args]

    return f"{ty.rvtype.Type.typestr()} {func.name}({', '.join(args)})"




