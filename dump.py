
from program import Program
from function import Function, TypeUsage
import sys, os

import simcopter
import codeview
import tpi
from item import Data


from collections import defaultdict
import pydemangler



extrafiles = defaultdict(list)

def dump(p: Program, dest: str):
    extrafiles.clear()

    # So... some of the contribs seem to be missing. They all seem to be uninitilized data.
    # We would rather have them in the dump, so lets scan nearby symbols to try and gues what module
    # they belong to.
    for sym in p.unknownContribs:
        if override := simcopter.unknowns.get(sym.Name):
            # If we have an override, use that.
            p.modules[override].unknowns += [(sym, None)]
            continue

        after = None
        before = None
        for idx in range(sym.index - 1, 0, -1):
            try:
                contrib = p.globals[idx].contrib
                if contrib.module:
                    #print(f"After {contrib.module.sourceFile}")
                    after = contrib.module
                    break
            except:
                try:
                    moduleId = p.globals[idx].getModuleId(p)
                    if moduleId:
                        #print(f"After {p.modules[moduleId].sourceFile}")
                        after = p.modules[moduleId]
                        break
                except AttributeError:
                    continue
        for idx in range(sym.index, len(p.globals)):
            try:
                contrib = p.globals[idx].contrib
                if contrib.module:
                    #print(f"Before {contrib.module.sourceFile}\n")
                    before = contrib.module
                    break
            except:
                try:
                    moduleId = p.globals[idx].getModuleId(p)
                    if moduleId:
                        #print(f"Before {p.modules[moduleId].sourceFile}\n")

                        before = p.modules[moduleId]
                        break
                except AttributeError:
                    continue
        if before == after:
            # The trivial case. We found symbols for the same module before and after.
            # it probally belongs to that module.
            before.unknowns += [(sym, None)]
        elif "S2global.obj" == after.name:
            # bias towards S2global.obj, which is the global data module.
            after.unknowns += [(sym, before.sourceFile)]
        else:
            before.unknowns += [(sym, after.sourceFile)]


    if not os.path.exists(dest):
        os.mkdir(dest)
    os.chdir(dest)

    for lib in p.libraries.values():
        if lib.is_dll() or lib.name in ["OLDNAMES.lib", "LIBCMTD.lib"]:
            print(f"Skipping {lib.name}")
            continue

        dump_lib(p, lib)

    for file, funcs in extrafiles.items():
        filename = fix_path(file, "")
        with open(filename, "w") as f:
            for func in funcs:
                f.write(f"// Function in module: {func.module.name}\n")
                f.write(func.as_code())



def fix_path(path, lib_prefix):
    path = path.lower().replace("\\", "/")
    if path.startswith(simcopter.source_prefix):
        return path[len(simcopter.source_prefix):]
    if path.startswith(simcopter.source_prefix2):
        return path[len(simcopter.source_prefix2):]
    return lib_prefix + path

def dump_lib(p, lib):
    prefix = simcopter.libs[lib.name]

    for module in lib.modules.values():
        try:
            # If we have an override, use that.
            new_source = simcopter.source_override[module.name.lower()]
        except KeyError:
            pass
        else:
            module.sourceFile = new_source
            print(f"Using override for {module.name}: {module.sourceFile}")

        module_path = fix_path(module.sourceFile, prefix)
        if module_path.lower().endswith((".asm")):
            print(f"Skipping assembly module {module.name} at {module.sourceFile}")
            continue
        dump_module(p, module, module_path)


def dump_module(p, module, path):
    dirname = os.path.dirname(path)
    module_source = module.sourceFile.lower()
    if dirname:
        os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w") as f:
        f.write(f"// Module: {module.name}\n")
        f.write(f"// Source: {module.sourceFile}\n")
        f.write(f"// autogenerated by simcopter_tool from PDB file\n\n")

        queue = set(module.used_types.keys())

        while queue:
            ty = queue.pop()
            cls = getattr(ty, '_class', None)
            cls = getattr(ty, '_def_class', cls)

            if cls:
                for base in cls.base:
                    if base.ty not in module.used_types:
                        queue.add(base.ty)
                    module.use_type(base.ty, cls, TypeUsage.BaseClass)


        for ty, users in module.used_types.items():
            fwd = ""
            nested = False
            if ty.is_fwdref():
                #breakpoint()
                fwd = " (forward reference)"
            try:
                if ty.properties.nested:
                    fwd += " (nested type)"
                    nested = True
            except AttributeError:
                pass
            f.write(f"// Type: {ty.typestr()}{fwd};\n")

            # if ty.is_fwdref() and not ty._definition:
            #     f.write(f"// Used by:\n")
            #     for user in users:
            #         if isinstance(user, Function):
            #             f.write(f"//   Function: {user.other} {user.mode}\n")
            #         else:
            #             f.write(f"//   Global: {user.other} {user.mode}\n")

            if nested:
                continue


            if hasattr(ty, 'as_code'):
                f.write(ty.as_code())
            f.write("\n")



        for contrib in module.sectionContribs:
            f.write(f"\n\n// Contribution: {contrib}\n")

            for _, thing in sorted(contrib.things.items()):
                if isinstance(thing, Function):
                    func = thing
                    if func.name.endswith(" destructor'") or func.name.endswith(" iterator'"):
                        f.write(f"// FUNCTION: {p.exename} 0x{func.address:08x}\n")
                        f.write(f"// {func.name}\n\n")
                        continue

                    if func.name.startswith("$E"):
                        # These are static initializers
                        # f.write(f"// FUNCTION: {p.exename} 0x{func.address:08x}\n")
                        # f.write(f"// {func.name}\n\n")
                        # continue
                        func.source_file = module_source
                        f.write(f"// STATIC INITIALIZER:\n")

                    if func.name == "ResFile::~ResFile":
                        # fixme: hack to skip this one function
                        func.source_file = module_source

                    func_source = func.source_file.lower()
                    if func_source != module_source:
                        if "msdev\\include" in func_source:
                            f.write(f"// LIBRARY: MSVC 0x{func.address:08x}\n")
                            f.write(f"// {func.name}\n\n")
                        else:
                            extrafiles[func_source].append(func)
                        continue

                    f.write(func.as_code())
                else:
                    sym = thing
                    if contrib.is_code():
                        segment = p.sections[sym.Segment]
                        address = segment.va + sym.Offset

                        f.write(f"// FUNCTION: {p.exename} 0x{address:08x}\n")
                        breakpoint()
                    else:
                        dump_global(f, p, sym, contrib)

        if module.unknowns:
            f.write("\n\n// Unknown globals:\n")
            f.write("// The PDB was slightly corrupted and we aren't sure which file these globals belong to.\n")

        for sym, other in module.unknowns:
            if other:
                f.write("\n// WARNING: this global might actually belong to: " + other + "\n")
            dump_global(f, p, sym, sym.contrib)


def dump_global(f, p, sym, contrib):
    segment = p.sections[sym.Segment]
    if segment.va is None:
        return
    address = segment.va + sym.Offset


    item = p.getItem(address)
    if item:
        if isinstance(item, Data):
            f.write(f"// GLOBAL: {p.exename} 0x{address:08x}\n")
        f.write(item.as_code())
        f.write("\n")

    else:
        name = pydemangler.demangle(sym.Name)
        f.write(f"// GLOBAL: {p.exename} 0x{address:08x}\n")
        if name and name != sym.Name:
            f.write(f"// Demangled: {name}\n")

            if sym.Type:

                print(sym.Type)
        f.write(f"// {sym.Name}\n")

